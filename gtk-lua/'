#include <signal.h>
#include <stdio.h>

#include <gtk/gtk.h>
#include <lauxlib.h>
#include <lua.h>
#include <lualib.h>

#define MY_LIBRARY_EXPORT __attribute__((visibility("default")))
#define dup_stack_top(L) (lua_pushvalue((L), -1))

#define paramless_retvoid(widget,fname) static int widget_widget_fname (lua_State *L) {\
  Widget *w=luaL_checkudata(L,"");\
  gtk_widget_fname(w->widget); return 0; };

// widget
paramless_retvoid(widget,show)




// A sample Lua function written in C
static int my_lua_function(lua_State *L) {
  int n = lua_gettop(L); /* number of arguments */
  printf("Number of arguments: %d\n", n);
  return 0; /* number of results */
}
static int another_fn(lua_State *L) {
  printf("stack count:%d\n",lua_gettop(L));
  lua_pushliteral(L,"A");
  lua_pushliteral(L,"A");
  printf("stack count:%d\n",lua_gettop(L));
  return 0;
}
static void activate(GtkApplication *app, gpointer user_data) {
  GtkWindow *win = GTK_WINDOW(gtk_window_new());
  gtk_window_set_application(win, app);
  gtk_window_present(win);
}
static int test(lua_State *L) {
  gtk_init();
  GMainContext *ctx = g_main_context_default();
  GtkWindow *win = GTK_WINDOW(gtk_window_new());
  gtk_window_present(win);
  while (true)
    g_main_context_iteration(ctx, true);
  return 0;
}

typedef struct App {
  GMainContext *g_main_ctx;
} App;

static int gtk_app(lua_State *L) {
  App *app = (App *)lua_newuserdata(L, sizeof(App));

  luaL_getmetatable(L, "GtkApp");
  lua_setmetatable(L, -2);
  GMainContext *g_main_ctx = g_main_context_default();
  gtk_init();
  app->g_main_ctx = g_main_ctx;
  return 1;
}
static int gtk_app_iteration(lua_State *L) {
  App *app = luaL_checkudata(L, 1, "GtkApp");
  bool block = lua_toboolean(L, 2);
  g_main_context_iteration(app->g_main_ctx, block);
  return 0;
}
static int gtk_app_gc(lua_State *L) {
  App *app = luaL_checkudata(L, 1, "GtkApp");
  g_main_context_unref(app->g_main_ctx);
  return 0;
}
static int gtk_app_run(lua_State *L) {
  App *app = luaL_checkudata(L, 1, "GtkApp");
  while (true)
    g_main_context_iteration(app->g_main_ctx, true);
  return 0;
}

typedef struct Window {
  GtkWindow *win;
} Window;
typedef struct Widget {
  GtkWidget *widget;
  void *field1;
  void *field2;
  void *field3;
} Widget;
typedef struct GtkWrapper {
  void *fields[4];
} GtkWrapper;

static int window_new(lua_State *L) {
  Window *win = (Window *)lua_newuserdata(L, sizeof(Window));
  luaL_getmetatable(L, "Window");
  lua_setmetatable(L, -2);
  win->win = GTK_WINDOW(gtk_window_new());
  return 1;
}
static int window_set_child(lua_State *L) {
  Window *win = (Window *)luaL_checkudata(L, 1, "Window");
  void *p = lua_touserdata(L, 2);
  gtk_window_set_child(win->win, GTK_WIDGET(((Widget *)p)->widget));
  return 0;
}
static int window_gc(lua_State *L) {
  Window *win = (Window *)luaL_checkudata(L, 1, "Window");
  gtk_window_destroy(GTK_WINDOW(win->win));
  return 0;
}
static int window_present(lua_State *L) {
  Window *win = (Window *)luaL_checkudata(L, 1, "Window");
  gtk_window_present(GTK_WINDOW(win->win));
  return 0;
}

static int label_new(lua_State *L) {
  Widget *label = (Widget *)lua_newuserdata(L, sizeof(Widget));
  luaL_getmetatable(L, "Label");
  lua_setmetatable(L, -2);
  label->widget = gtk_label_new(NULL);
  return 1;
}
static int label_gc(lua_State *L) {
  Widget *label = (Widget *)luaL_checkudata(L, 1, "Label");
  // printf("destroy label");
  // g_object_unref(label);
  return 0;
}
static int label_set_text(lua_State *L) {
  Widget *label = (Widget *)luaL_checkudata(L, 1, "Label");
  char *s = luaL_checkstring(L, 2);
  gtk_label_set_text(GTK_LABEL(label->widget), s);
  return 0;
}

static int box_new(lua_State *L) {
  Widget *label = (Widget *)lua_newuserdata(L, sizeof(Widget));
  luaL_getmetatable(L, "Box");
  lua_setmetatable(L, -2);
  label->widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 10);
  return 1;
}
static int box_append(lua_State *L) {
  Widget *box = (Widget *)luaL_checkudata(L, 1, "Box");
  Widget *p = (Widget *)lua_touserdata(L, 2);
  gtk_box_append(GTK_BOX(box->widget), p->widget);
  return 0;
}

static int scroll_win_new(lua_State *L) {
  Widget *widget = (Widget *)lua_newuserdata(L, sizeof(Widget));
  luaL_getmetatable(L, "ScrollWin");
  lua_setmetatable(L, -2);
  widget->widget = gtk_scrolled_window_new();
  return 1;
}
static int scroll_win_new_set_child(lua_State *L) {
  Widget *w = (Widget *)luaL_checkudata(L, 1, "ScrollWin");
  Widget *p = (Widget *)lua_touserdata(L, 2);
  gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(w->widget), p->widget);
  return 1;
}
static int listview_new(lua_State *L) {
  Widget *widget = (Widget *)lua_newuserdata(L, sizeof(Widget));
  luaL_getmetatable(L, "ListView");
  lua_setmetatable(L, -2);
  widget->widget = gtk_list_view_new(NULL, NULL);
  gtk_widget_set_vexpand(widget->widget,true);
  return 1;
}
static int listview_set_moda(lua_State *L) {
  int argc = lua_gettop(L);
  if (argc != 2) {
    return 0;
  }

  Widget *w = (Widget *)luaL_checkudata(L, 1, "ListView");
  luaL_checktype(L, 2, LUA_TTABLE);
  lua_len(L, 2);
  int cnt = lua_tonumber(L, 3);
  lua_pop(L, 1);

  GtkStringList *list_model = gtk_string_list_new(NULL);
  int i = 1;
  while (i <= cnt) {
    lua_rawgeti(L, -1, i);
    const char *s = luaL_checkstring(L, -1);
    lua_pop(L, 1);
    gtk_string_list_append(list_model, s);
    i++;
  }
  GtkSelectionModel *m =
      GTK_SELECTION_MODEL(gtk_no_selection_new(G_LIST_MODEL(list_model)));
  gtk_list_view_set_model(GTK_LIST_VIEW(w->widget), m);
  return 0;
}

static int listview_set_item_factory(lua_State *L) {
  Widget *w = (Widget *)luaL_checkudata(L, 1, "ListView");
  GtkWrapper *wrapper =
      (GtkWrapper *)luaL_checkudata(L, 2, "SignalItemFactory");
  gtk_list_view_set_factory(GTK_LIST_VIEW(w->widget),
                            GTK_LIST_ITEM_FACTORY(wrapper->fields[0]));
  return 0;
}

void signal_item_on_bind(GtkSignalListItemFactory *self, GObject *object,
                         gpointer user_data) {
  GtkListItem *item = GTK_LIST_ITEM(object);

  lua_State *L = (lua_State *)user_data;
  lua_pushlightuserdata(L, signal_item_on_bind);
  lua_gettable(L, LUA_REGISTRYINDEX); // put onsetup on stack
  lua_pushlightuserdata(L, item);

  lua_gettable(L, LUA_REGISTRYINDEX); // put list item child on stack
  const char *content = gtk_string_object_get_string(

  GTK_STRING_OBJECT(gtk_list_item_get_item(item))
  );
  lua_pushstring(L,content);

  lua_call(L, 2, 0);
  lua_settop(L,1);
}
void signal_item_on_setup(GtkSignalListItemFactory *self, GObject *object,
                          gpointer user_data) {
  GtkListItem *item = GTK_LIST_ITEM(object);

  lua_State *L = (lua_State *)user_data;
  lua_pushlightuserdata(L, signal_item_on_setup);
  lua_gettable(L, LUA_REGISTRYINDEX); // put onsetup on stack
  lua_call(L, 0, 1);
  void *p = lua_touserdata(L, -1);
  gtk_list_item_set_child(item, ((Widget *)p)->widget);
  // put on the registry
  lua_pushlightuserdata(L, item); // key
  lua_pushvalue(L, -2);
  lua_settable(L, LUA_REGISTRYINDEX); // v on top k below top
  lua_settop(L,1);
}
static int signal_item_factory_new(lua_State *L) {
  luaL_checktype(L, 1, LUA_TFUNCTION); // setup callback (Lua fn)

  lua_pushlightuserdata(L, (void *)signal_item_on_setup);
  lua_pushvalue(L, 1);                // put setup on top
  lua_settable(L, LUA_REGISTRYINDEX); // set to registry

  luaL_checktype(L, 2, LUA_TFUNCTION); // bind callback (Lua fn)
  lua_pushlightuserdata(L, (void *)signal_item_on_bind);
  lua_pushvalue(L, 2);                // put setup on top
  lua_settable(L, LUA_REGISTRYINDEX); // registry[signal_item_on_bind]=onbind

  GtkWrapper *wrapper = (GtkWrapper *)lua_newuserdata(L, sizeof(GtkWrapper));
  luaL_getmetatable(L, "SignalItemFactory");
  lua_setmetatable(L, -2);

  wrapper->fields[0] = gtk_signal_list_item_factory_new();
  g_signal_connect(wrapper->fields[0], "setup",
                   G_CALLBACK(signal_item_on_setup), L);
  g_signal_connect(wrapper->fields[0], "bind", G_CALLBACK(signal_item_on_bind),
                   L);

  return 1;
}

static int entry_new(lua_State *L) {
  Widget *widget = (Widget *)lua_newuserdata(L, sizeof(Widget));
  luaL_getmetatable(L, "Entry");
  lua_setmetatable(L, -2);
  widget->widget = gtk_entry_new();
  return 1;
}
static void on_entry_text_changed(GtkEntry *self,gpointer user_data) {
  lua_State *L = user_data;
  lua_pushlightuserdata(L,entry_new);
  lua_gettable(L,LUA_REGISTRYINDEX);
  GtkEntryBuffer *buffer= gtk_entry_get_buffer(self);
  const char *s = gtk_entry_buffer_get_text(buffer);
  lua_pushstring(L,s);

  lua_call(L,1,0);
  lua_settop(L,1);
}
static int entry_connect_changed(lua_State *L) {
  Widget *w = (Widget *)luaL_checkudata(L, 1, "Entry");
  luaL_checktype(L, 2, LUA_TFUNCTION);
  lua_pushlightuserdata(L, entry_new);
  lua_pushvalue(L,2);
  lua_settable(L, LUA_REGISTRYINDEX);
  g_signal_connect(w->widget, "changed", G_CALLBACK(on_entry_text_changed),
                   L);
  return 0;
}

static void setup_metatable(lua_State *L, const char *name,
                            const luaL_Reg *items) {
  luaL_newmetatable(L, name);
  dup_stack_top(L);
  lua_setfield(L, -2, "__index"); // mt.__index = mt

  int i = 0;
  while (items[i].name != NULL) {
    lua_pushcfunction(L, items[i].func);
    lua_setfield(L, -2, items[i].name);
    i++;
  }
  lua_pop(L, 1);
}

MY_LIBRARY_EXPORT int luaopen_lua(lua_State *L) {
  const luaL_Reg gtkapp[] = {{"__gc", gtk_app_gc},
                             {"iteration", gtk_app_iteration},
                             {"run", gtk_app_run},
                             {NULL, NULL}};

  setup_metatable(L, "GtkApp", gtkapp);
  const luaL_Reg win[] = {{"__gc", window_gc},

                          {"set_child", window_set_child},
                          {"present", window_present},
                          {NULL, NULL}};
  setup_metatable(L, "Window", win);
  const luaL_Reg label[] = {
      {"__gc", label_gc}, 
    {"set_label", label_set_text}, 
    {"set_markup", label_set_text}, 
    {"set_text", label_set_text}, 
    {NULL, NULL}};
  setup_metatable(L, "Label", label);
  const luaL_Reg box[] = {{"append", box_append}, {NULL, NULL}};
  setup_metatable(L, "Box", box);
  const luaL_Reg scrolled[] = {{"set_child", scroll_win_new_set_child},
                               {NULL, NULL}};
  setup_metatable(L, "ScrollWin", scrolled);
  const luaL_Reg listview[] = {{"set_model", listview_set_moda},
                               {"set_factory", listview_set_item_factory},
                               {NULL, NULL}};
  setup_metatable(L, "ListView", listview);

  const luaL_Reg signal_item[] = {{NULL, NULL}};
  setup_metatable(L, "SignalItemFactory", signal_item);

  const luaL_Reg entry[] = {{"connect_change", entry_connect_changed},
                            {NULL, NULL}};
  setup_metatable(L, "Entry", entry);

  static const luaL_Reg mylib[] = {
      {"test", test},
      {"app", gtk_app},
      {"box", box_new},
      {"scrolled_win",scroll_win_new},
      {"win", window_new},
      {"label", label_new},
      {"entry", entry_new},
      {"text_box", entry_new},
      {"my_lua_function", my_lua_function},
      {"another_fn",another_fn},
      {"listview", listview_new},
      {"list_view", listview_new},
      {"signal_item_factory", signal_item_factory_new},

      {NULL, NULL} // Sentinel
  };
  luaL_newlib(L, mylib);
  return 1;
}
